/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import React, { createContext, useContext, useState, useCallback, useMemo, useEffect } from 'react';

export interface ExploreAlertConfig {
  title: string;
  bodyText: string | React.ReactNode;
  type?: 'info' | 'warning' | 'error';
  primaryButtonText?: string;
  secondaryButtonText?: string;
  primaryButtonAction?: () => void;
  secondaryButtonAction?: () => void;
}

interface ExploreAlertContextType {
  alertConfig: ExploreAlertConfig | null;
  setAlert: (config: ExploreAlertConfig | null) => void;
  clearAlert: () => void;
}

const ExploreAlertContext = createContext<ExploreAlertContextType | undefined>(
  undefined,
);

// ç”¨äºè¿½è¸ª Provider å®ä¾‹
let providerInstanceId = 0;

// å…¨å±€çŠ¶æ€è¿½è¸ªï¼Œç”¨äºæ£€æµ‹æ˜¯å¦æœ‰å¤šä¸ªå®ä¾‹æˆ–é‡æ–°åˆ›å»º
type AlertConfigHistoryEntry = {
  timestamp: number;
  value: ExploreAlertConfig | null;
  reason: string;
};

const providerInstances = new Map<number, {
  createdAt: number;
  alertConfigHistory: AlertConfigHistoryEntry[];
}>();

export const ExploreAlertProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const instanceId = React.useRef(++providerInstanceId);
  const mountTime = React.useRef(Date.now());
  
  // åˆå§‹åŒ–å®ä¾‹è¿½è¸ª
  React.useEffect(() => {
    providerInstances.set(instanceId.current, {
      createdAt: mountTime.current,
      alertConfigHistory: [{ timestamp: Date.now(), value: null, reason: 'initial state' }],
    });
    console.log(`ğŸ”µ ExploreAlertProvider: instance ${instanceId.current} MOUNTED at ${new Date(mountTime.current).toISOString()}`);
    console.log(`ğŸ”µ Total active instances: ${providerInstances.size}`);
    console.log(`ğŸ”µ All instances:`, Array.from(providerInstances.keys()));
    
    return () => {
      const instance = providerInstances.get(instanceId.current);
      const lifetime = Date.now() - mountTime.current;
      console.log(`ğŸ”´ ExploreAlertProvider: instance ${instanceId.current} UNMOUNTING after ${lifetime}ms`);
      console.log(`ğŸ”´ Instance ${instanceId.current} alertConfig history:`, instance?.alertConfigHistory);
      providerInstances.delete(instanceId.current);
      console.log(`ğŸ”´ Remaining active instances: ${providerInstances.size}`);
    };
  }, []);
  
  console.log(`âšª ExploreAlertProvider: instance ${instanceId.current} rendering`);
  
  const [alertConfig, setAlertConfig] = useState<ExploreAlertConfig | null>(
    null,
  );

  // ä½¿ç”¨å‡½æ•°å¼æ›´æ–°ç¡®ä¿çŠ¶æ€æ­£ç¡®æ›´æ–°
  const setAlert = useCallback((config: ExploreAlertConfig | null) => {
    const timestamp = Date.now();
    const reason = config === null ? 'setAlert(null) called' : 'setAlert(config) called';
    
    console.log(`ğŸŸ¢ ExploreAlertProvider: instance ${instanceId.current} - setAlert called with`, config);
    console.log(`ğŸŸ¢ ExploreAlertProvider: instance ${instanceId.current} - setAlert config === null?`, config === null);
    console.log(`ğŸŸ¢ ExploreAlertProvider: instance ${instanceId.current} - setAlert config === undefined?`, config === undefined);
    console.trace(`ğŸŸ¢ ExploreAlertProvider: instance ${instanceId.current} - setAlert call stack`);
    
    setAlertConfig(prevConfig => {
      console.log(`ğŸŸ¢ ExploreAlertProvider: instance ${instanceId.current} - updating from`, prevConfig, 'to', config);
      
      // è®°å½•çŠ¶æ€å˜åŒ–å†å²
      const instance = providerInstances.get(instanceId.current);
      if (instance) {
        instance.alertConfigHistory.push({
          timestamp,
          value: config,
          reason,
        });
        // åªä¿ç•™æœ€è¿‘ 20 æ¡è®°å½•
        if (instance.alertConfigHistory.length > 20) {
          instance.alertConfigHistory.shift();
        }
      }
      
      if (prevConfig !== config) {
        console.log(`ğŸŸ¢ ExploreAlertProvider: instance ${instanceId.current} - state will change`);
        if (config === null) {
          console.warn(`âš ï¸ ExploreAlertProvider: instance ${instanceId.current} - WARNING: setting alertConfig to null!`);
          console.warn(`âš ï¸ Previous value was:`, prevConfig);
          console.trace(`âš ï¸ ExploreAlertProvider: instance ${instanceId.current} - setAlert(null) call stack`);
        } else {
          console.log(`âœ… ExploreAlertProvider: instance ${instanceId.current} - setting alertConfig to:`, config);
        }
      } else {
        console.log(`âšª ExploreAlertProvider: instance ${instanceId.current} - state unchanged (same reference)`);
      }
      return config;
    });
  }, []);

  const clearAlert = useCallback(() => {
    console.log(`ExploreAlertProvider: instance ${instanceId.current} - clearAlert called`);
    console.trace('ExploreAlertProvider: clearAlert call stack');
    setAlertConfig(prevConfig => {
      console.log(`ExploreAlertProvider: instance ${instanceId.current} - clearing alert from`, prevConfig);
      return null;
    });
  }, []);

  // æ·»åŠ è°ƒè¯•æ—¥å¿—æ¥è¿½è¸ª alertConfig çš„å˜åŒ–
  useEffect(() => {
    const timestamp = Date.now();
    const instance = providerInstances.get(instanceId.current);
    
    console.log(`ğŸŸ¡ ExploreAlertProvider: instance ${instanceId.current} - alertConfig state changed to`, alertConfig);
    
    if (alertConfig === null) {
      // æ£€æŸ¥æ˜¯å¦æ˜¯åˆå§‹åŒ–ï¼ˆç¬¬ä¸€æ¬¡æ¸²æŸ“ï¼‰
      const isInitialRender = instance?.alertConfigHistory.length === 1 && 
                              instance.alertConfigHistory[0].value === null;
      
      if (!isInitialRender) {
        console.warn(`âš ï¸ ExploreAlertProvider: instance ${instanceId.current} - WARNING: alertConfig became null!`);
        console.warn(`âš ï¸ Instance lifetime: ${Date.now() - mountTime.current}ms`);
        console.warn(`âš ï¸ AlertConfig history:`, instance?.alertConfigHistory);
        console.trace(`âš ï¸ ExploreAlertProvider: instance ${instanceId.current} - alertConfig became null - call stack`);
        
        // è®°å½•åˆ°å†å²
        if (instance) {
          instance.alertConfigHistory.push({
            timestamp,
            value: null,
            reason: 'state changed to null (unknown reason)',
          });
        }
      } else {
        console.log(`â„¹ï¸ ExploreAlertProvider: instance ${instanceId.current} - initial state (null)`);
      }
    } else {
      console.log(`âœ… ExploreAlertProvider: instance ${instanceId.current} - alertConfig has value:`, alertConfig);
    }
  }, [alertConfig]);
  
  // è¿½è¸ªæ¯æ¬¡æ¸²æŸ“æ—¶çš„ alertConfig å€¼
  console.log(`âšª ExploreAlertProvider: instance ${instanceId.current} - render with alertConfig:`, alertConfig);

  // ä½¿ç”¨ useMemo ç¡®ä¿å½“ alertConfig å˜åŒ–æ—¶ï¼Œvalue å¯¹è±¡å¼•ç”¨ä¹Ÿä¼šå˜åŒ–
  // è¿™æ · React Context æ‰èƒ½æ­£ç¡®æ£€æµ‹åˆ°å˜åŒ–å¹¶è§¦å‘æ›´æ–°
  const value: ExploreAlertContextType = useMemo(
    () => {
      const newValue = {
        alertConfig,
        setAlert,
        clearAlert,
      };
      console.log(`ğŸ”· ExploreAlertContext: instance ${instanceId.current} - creating value object with useMemo`, {
        'instanceId': instanceId.current,
        'newValue.alertConfig': newValue.alertConfig,
        'newValue.alertConfig type': typeof newValue.alertConfig,
        'newValue.alertConfig === null': newValue.alertConfig === null,
        'newValue.alertConfig === undefined': newValue.alertConfig === undefined,
        'alertConfig from state': alertConfig,
        'hasSetAlert': !!newValue.setAlert,
        'hasClearAlert': !!newValue.clearAlert,
        'value object keys': Object.keys(newValue),
        'value object reference': newValue,
      });
      return newValue;
    },
    [alertConfig, setAlert, clearAlert], // ä¾èµ– alertConfigï¼Œç¡®ä¿å˜åŒ–æ—¶é‡æ–°åˆ›å»º
  );
  
  // é¢å¤–æ£€æŸ¥ï¼šéªŒè¯ useMemo æ˜¯å¦åœ¨ alertConfig å˜åŒ–æ—¶é‡æ–°è®¡ç®—
  // ä»¥åŠ value å¯¹è±¡ä¸­çš„ alertConfig æ˜¯å¦ä¸çŠ¶æ€ä¸­çš„ alertConfig ä¸€è‡´
  useEffect(() => {
    const valueMatchesState = value.alertConfig === alertConfig;
    console.log(`ğŸ”· ExploreAlertContext: instance ${instanceId.current} - useMemo dependencies check`, {
      'alertConfig from state': alertConfig,
      'value.alertConfig from context': value.alertConfig,
      'values match?': valueMatchesState,
      'setAlert reference': setAlert,
      'clearAlert reference': clearAlert,
      'value object reference': value,
    });
    
    if (!valueMatchesState) {
      console.error(`âŒ ExploreAlertContext: instance ${instanceId.current} - MISMATCH!`);
      console.error(`âŒ State alertConfig:`, alertConfig);
      console.error(`âŒ Value alertConfig:`, value.alertConfig);
      console.error(`âŒ This should never happen!`);
    }
  }, [alertConfig, setAlert, clearAlert, value]);

  return (
    <ExploreAlertContext.Provider value={value}>
      {children}
    </ExploreAlertContext.Provider>
  );
};

export const useExploreAlert = () => {
  const context = useContext(ExploreAlertContext);
  if (!context) {
    throw new Error('useExploreAlert must be used within ExploreAlertProvider');
  }
  
  // è°ƒè¯•æ—¥å¿—ï¼šæ£€æŸ¥ä» Context è·å–çš„å€¼
  const componentName = new Error().stack?.split('\n')[2]?.trim() || 'unknown';
  console.log(`ğŸ” useExploreAlert called from:`, componentName);
  console.log(`ğŸ” useExploreAlert: context from useContext`, context);
  console.log(`ğŸ” useExploreAlert: context.alertConfig`, context.alertConfig);
  console.log(`ğŸ” useExploreAlert: context.alertConfig type`, typeof context.alertConfig);
  console.log(`ğŸ” useExploreAlert: context.alertConfig === null?`, context.alertConfig === null);
  console.log(`ğŸ” useExploreAlert: context.alertConfig === undefined?`, context.alertConfig === undefined);
  console.log(`ğŸ” useExploreAlert: context keys`, Object.keys(context));
  console.log(`ğŸ” useExploreAlert: has alertConfig property?`, 'alertConfig' in context);
  console.log(`ğŸ” useExploreAlert: context.alertConfig value`, JSON.stringify(context.alertConfig));
  
  // æ£€æŸ¥æ˜¯å¦æœ‰å¤šä¸ª Provider å®ä¾‹
  if (providerInstances.size > 1) {
    console.warn(`âš ï¸ WARNING: Multiple ExploreAlertProvider instances detected! Count: ${providerInstances.size}`);
    console.warn(`âš ï¸ Active instances:`, Array.from(providerInstances.keys()));
    console.warn(`âš ï¸ This may cause context state to be lost!`);
  }
  
  return context;
};

// å¯¼å‡ºè°ƒè¯•å‡½æ•°ï¼Œå¯ä»¥åœ¨æµè§ˆå™¨æ§åˆ¶å°ä¸­ä½¿ç”¨
if (typeof window !== 'undefined') {
  (window as any).__exploreAlertDebug = {
    getInstances: () => Array.from(providerInstances.entries()),
    getInstanceHistory: (id: number) => providerInstances.get(id)?.alertConfigHistory,
    getAllHistory: () => {
      const all: Record<number, any> = {};
      providerInstances.forEach((value, key) => {
        all[key] = value;
      });
      return all;
    },
  };
}


